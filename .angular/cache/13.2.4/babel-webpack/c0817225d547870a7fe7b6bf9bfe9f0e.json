{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, Component, Inject, ViewChild, Output, forwardRef, Input, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { fromEvent } from 'rxjs';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [\"editorContainer\"];\nconst NGX_MONACO_EDITOR_CONFIG = new InjectionToken('NGX_MONACO_EDITOR_CONFIG');\nlet loadedMonaco = false;\nlet loadPromise;\nlet BaseEditor = /*#__PURE__*/(() => {\n  class BaseEditor {\n    constructor(config) {\n      this.config = config;\n      this.onInit = new EventEmitter();\n    }\n\n    ngAfterViewInit() {\n      if (loadedMonaco) {\n        // Wait until monaco editor is available\n        loadPromise.then(() => {\n          this.initMonaco(this._options);\n        });\n      } else {\n        loadedMonaco = true;\n        loadPromise = new Promise(resolve => {\n          const baseUrl = (this.config.baseUrl || './assets') + '/monaco-editor/min/vs';\n\n          if (typeof window.monaco === 'object') {\n            resolve();\n            return;\n          }\n\n          const onGotAmdLoader = () => {\n            // Load monaco\n            window.require.config({\n              paths: {\n                'vs': `${baseUrl}`\n              }\n            });\n\n            window.require([`vs/editor/editor.main`], () => {\n              if (typeof this.config.onMonacoLoad === 'function') {\n                this.config.onMonacoLoad();\n              }\n\n              this.initMonaco(this._options);\n              resolve();\n            });\n          }; // Load AMD loader if necessary\n\n\n          if (!window.require) {\n            const loaderScript = document.createElement('script');\n            loaderScript.type = 'text/javascript';\n            loaderScript.src = `${baseUrl}/loader.js`;\n            loaderScript.addEventListener('load', onGotAmdLoader);\n            document.body.appendChild(loaderScript);\n          } else {\n            onGotAmdLoader();\n          }\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      if (this._windowResizeSubscription) {\n        this._windowResizeSubscription.unsubscribe();\n      }\n\n      if (this._editor) {\n        this._editor.dispose();\n\n        this._editor = undefined;\n      }\n    }\n\n  }\n\n  BaseEditor.ɵfac = function BaseEditor_Factory(t) {\n    return new (t || BaseEditor)(i0.ɵɵdirectiveInject(NGX_MONACO_EDITOR_CONFIG));\n  };\n\n  BaseEditor.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BaseEditor,\n    selectors: [[\"ng-component\"]],\n    viewQuery: function BaseEditor_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._editorContainer = _t.first);\n      }\n    },\n    outputs: {\n      onInit: \"onInit\"\n    },\n    decls: 0,\n    vars: 0,\n    template: function BaseEditor_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return BaseEditor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet EditorComponent = /*#__PURE__*/(() => {\n  class EditorComponent extends BaseEditor {\n    constructor(zone, editorConfig) {\n      super(editorConfig);\n      this.zone = zone;\n      this.editorConfig = editorConfig;\n      this._value = '';\n\n      this.propagateChange = _ => {};\n\n      this.onTouched = () => {};\n    }\n\n    set options(options) {\n      this._options = Object.assign({}, this.config.defaultOptions, options);\n\n      if (this._editor) {\n        this._editor.dispose();\n\n        this.initMonaco(options);\n      }\n    }\n\n    get options() {\n      return this._options;\n    }\n\n    set model(model) {\n      this.options.model = model;\n\n      if (this._editor) {\n        this._editor.dispose();\n\n        this.initMonaco(this.options);\n      }\n    }\n\n    writeValue(value) {\n      this._value = value || ''; // Fix for value change while dispose in process.\n\n      setTimeout(() => {\n        if (this._editor && !this.options.model) {\n          this._editor.setValue(this._value);\n        }\n      });\n    }\n\n    registerOnChange(fn) {\n      this.propagateChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    initMonaco(options) {\n      const hasModel = !!options.model;\n\n      if (hasModel) {\n        const model = monaco.editor.getModel(options.model.uri || '');\n\n        if (model) {\n          options.model = model;\n          options.model.setValue(this._value);\n        } else {\n          options.model = monaco.editor.createModel(options.model.value, options.model.language, options.model.uri);\n        }\n      }\n\n      this._editor = monaco.editor.create(this._editorContainer.nativeElement, options);\n\n      if (!hasModel) {\n        this._editor.setValue(this._value);\n      }\n\n      this._editor.onDidChangeModelContent(e => {\n        const value = this._editor.getValue(); // value is not propagated to parent when executing outside zone.\n\n\n        this.zone.run(() => {\n          this.propagateChange(value);\n          this._value = value;\n        });\n      });\n\n      this._editor.onDidBlurEditorWidget(() => {\n        this.onTouched();\n      }); // refresh layout on resize event.\n\n\n      if (this._windowResizeSubscription) {\n        this._windowResizeSubscription.unsubscribe();\n      }\n\n      this._windowResizeSubscription = fromEvent(window, 'resize').subscribe(() => this._editor.layout());\n      this.onInit.emit(this._editor);\n    }\n\n  }\n\n  EditorComponent.ɵfac = function EditorComponent_Factory(t) {\n    return new (t || EditorComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(NGX_MONACO_EDITOR_CONFIG));\n  };\n\n  EditorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: EditorComponent,\n    selectors: [[\"ngx-monaco-editor\"]],\n    inputs: {\n      options: \"options\",\n      model: \"model\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => EditorComponent),\n      multi: true\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"editor-container\"], [\"editorContainer\", \"\"]],\n    template: function EditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] {\\n          display: block;\\n          height: 200px;\\n      }\\n\\n      .editor-container[_ngcontent-%COMP%] {\\n          width: 100%;\\n          height: 98%;\\n      }\"]\n  });\n  return EditorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DiffEditorComponent = /*#__PURE__*/(() => {\n  class DiffEditorComponent extends BaseEditor {\n    constructor(editorConfig) {\n      super(editorConfig);\n      this.editorConfig = editorConfig;\n    }\n\n    set options(options) {\n      this._options = Object.assign({}, this.config.defaultOptions, options);\n\n      if (this._editor) {\n        this._editor.dispose();\n\n        this.initMonaco(options);\n      }\n    }\n\n    get options() {\n      return this._options;\n    }\n\n    set originalModel(model) {\n      this._originalModel = model;\n\n      if (this._editor) {\n        this._editor.dispose();\n\n        this.initMonaco(this.options);\n      }\n    }\n\n    set modifiedModel(model) {\n      this._modifiedModel = model;\n\n      if (this._editor) {\n        this._editor.dispose();\n\n        this.initMonaco(this.options);\n      }\n    }\n\n    initMonaco(options) {\n      if (!this._originalModel || !this._modifiedModel) {\n        throw new Error('originalModel or modifiedModel not found for ngx-monaco-diff-editor');\n      }\n\n      this._originalModel.language = this._originalModel.language || options.language;\n      this._modifiedModel.language = this._modifiedModel.language || options.language;\n      let originalModel = monaco.editor.createModel(this._originalModel.code, this._originalModel.language);\n      let modifiedModel = monaco.editor.createModel(this._modifiedModel.code, this._modifiedModel.language);\n      this._editorContainer.nativeElement.innerHTML = '';\n      const theme = options.theme;\n      this._editor = monaco.editor.createDiffEditor(this._editorContainer.nativeElement, options);\n      options.theme = theme;\n\n      this._editor.setModel({\n        original: originalModel,\n        modified: modifiedModel\n      }); // refresh layout on resize event.\n\n\n      if (this._windowResizeSubscription) {\n        this._windowResizeSubscription.unsubscribe();\n      }\n\n      this._windowResizeSubscription = fromEvent(window, 'resize').subscribe(() => this._editor.layout());\n      this.onInit.emit(this._editor);\n    }\n\n  }\n\n  DiffEditorComponent.ɵfac = function DiffEditorComponent_Factory(t) {\n    return new (t || DiffEditorComponent)(i0.ɵɵdirectiveInject(NGX_MONACO_EDITOR_CONFIG));\n  };\n\n  DiffEditorComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DiffEditorComponent,\n    selectors: [[\"ngx-monaco-diff-editor\"]],\n    inputs: {\n      options: \"options\",\n      originalModel: \"originalModel\",\n      modifiedModel: \"modifiedModel\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"editor-container\"], [\"editorContainer\", \"\"]],\n    template: function DiffEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] {\\n      display: block;\\n      height: 200px;\\n    }\\n\\n    .editor-container[_ngcontent-%COMP%] {\\n      width: 100%;\\n      height: 98%;\\n    }\"]\n  });\n  return DiffEditorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MonacoEditorModule = /*#__PURE__*/(() => {\n  class MonacoEditorModule {\n    static forRoot(config = {}) {\n      return {\n        ngModule: MonacoEditorModule,\n        providers: [{\n          provide: NGX_MONACO_EDITOR_CONFIG,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  MonacoEditorModule.ɵfac = function MonacoEditorModule_Factory(t) {\n    return new (t || MonacoEditorModule)();\n  };\n\n  MonacoEditorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MonacoEditorModule\n  });\n  MonacoEditorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return MonacoEditorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { DiffEditorComponent, EditorComponent, MonacoEditorModule, NGX_MONACO_EDITOR_CONFIG }; //# sourceMappingURL=ngx-monaco-editor.js.map","map":null,"metadata":{},"sourceType":"module"}